/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "./common";

export interface HodlInterface extends utils.Interface {
  functions: {
    "sold()": FunctionFragment;
    "active()": FunctionFragment;
    "sizeMultipliers(address,uint256)": FunctionFragment;
    "etherCollected()": FunctionFragment;
    "instantBuy(address)": FunctionFragment;
    "totalRefferred(address)": FunctionFragment;
    "longBuy(address)": FunctionFragment;
    "latestOrderId()": FunctionFragment;
    "totalInvested(address)": FunctionFragment;
    "tokenAddress()": FunctionFragment;
    "isClaimed(uint256)": FunctionFragment;
    "endPresale()": FunctionFragment;
    "mediumBuy(address)": FunctionFragment;
    "lockupOf(uint256)": FunctionFragment;
    "tokenFallback(address,uint256,bytes)": FunctionFragment;
    "tokensRemaining()": FunctionFragment;
    "tokensIfInvest(address,uint256)": FunctionFragment;
    "setInitialInvestedAmount(address[],uint256[])": FunctionFragment;
    "shortBuy(address)": FunctionFragment;
    "buyerOf(uint256)": FunctionFragment;
    "redeem(uint256)": FunctionFragment;
    "amountOf(uint256)": FunctionFragment;
    "setVips(address[])": FunctionFragment;
    "isVIP(address)": FunctionFragment;
    "hardCap()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "sold"
      | "active"
      | "sizeMultipliers"
      | "etherCollected"
      | "instantBuy"
      | "totalRefferred"
      | "longBuy"
      | "latestOrderId"
      | "totalInvested"
      | "tokenAddress"
      | "isClaimed"
      | "endPresale"
      | "mediumBuy"
      | "lockupOf"
      | "tokenFallback"
      | "tokensRemaining"
      | "tokensIfInvest"
      | "setInitialInvestedAmount"
      | "shortBuy"
      | "buyerOf"
      | "redeem"
      | "amountOf"
      | "setVips"
      | "isVIP"
      | "hardCap"
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "sold", values?: undefined): string;
  encodeFunctionData(functionFragment: "active", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "sizeMultipliers",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "etherCollected",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "instantBuy", values: [string]): string;
  encodeFunctionData(
    functionFragment: "totalRefferred",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "longBuy", values: [string]): string;
  encodeFunctionData(
    functionFragment: "latestOrderId",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "totalInvested",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "tokenAddress",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "isClaimed",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "endPresale",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "mediumBuy", values: [string]): string;
  encodeFunctionData(
    functionFragment: "lockupOf",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "tokenFallback",
    values: [string, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "tokensRemaining",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "tokensIfInvest",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setInitialInvestedAmount",
    values: [string[], BigNumberish[]]
  ): string;
  encodeFunctionData(functionFragment: "shortBuy", values: [string]): string;
  encodeFunctionData(
    functionFragment: "buyerOf",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "redeem",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "amountOf",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "setVips", values: [string[]]): string;
  encodeFunctionData(functionFragment: "isVIP", values: [string]): string;
  encodeFunctionData(functionFragment: "hardCap", values?: undefined): string;

  decodeFunctionResult(functionFragment: "sold", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "active", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "sizeMultipliers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "etherCollected",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "instantBuy", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "totalRefferred",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "longBuy", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "latestOrderId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalInvested",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokenAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "isClaimed", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "endPresale", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "mediumBuy", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "lockupOf", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "tokenFallback",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokensRemaining",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokensIfInvest",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setInitialInvestedAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "shortBuy", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "buyerOf", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "redeem", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "amountOf", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setVips", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isVIP", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "hardCap", data: BytesLike): Result;

  events: {
    "Activated(uint256)": EventFragment;
    "Finished(uint256)": EventFragment;
    "Purchase(address,uint256,uint256,uint256,uint256,uint256,string)": EventFragment;
    "Claim(address,uint256,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "Activated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Finished"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Purchase"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Claim"): EventFragment;
}

export interface ActivatedEventObject {
  time: BigNumber;
}
export type ActivatedEvent = TypedEvent<[BigNumber], ActivatedEventObject>;

export type ActivatedEventFilter = TypedEventFilter<ActivatedEvent>;

export interface FinishedEventObject {
  time: BigNumber;
}
export type FinishedEvent = TypedEvent<[BigNumber], FinishedEventObject>;

export type FinishedEventFilter = TypedEventFilter<FinishedEvent>;

export interface PurchaseEventObject {
  purchaser: string;
  id: BigNumber;
  amount: BigNumber;
  etherPaid: BigNumber;
  purchasedAt: BigNumber;
  redeemAt: BigNumber;
  hodltype: string;
}
export type PurchaseEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, string],
  PurchaseEventObject
>;

export type PurchaseEventFilter = TypedEventFilter<PurchaseEvent>;

export interface ClaimEventObject {
  purchaser: string;
  id: BigNumber;
  amount: BigNumber;
}
export type ClaimEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  ClaimEventObject
>;

export type ClaimEventFilter = TypedEventFilter<ClaimEvent>;

export interface Hodl extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: HodlInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    sold(overrides?: CallOverrides): Promise<[BigNumber]>;

    active(overrides?: CallOverrides): Promise<[boolean]>;

    sizeMultipliers(
      addy: string,
      toBeInvested: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber] & { m: BigNumber; d: BigNumber }>;

    etherCollected(overrides?: CallOverrides): Promise<[BigNumber]>;

    instantBuy(
      ref: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    totalRefferred(
      addy: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    longBuy(
      ref: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    latestOrderId(overrides?: CallOverrides): Promise<[BigNumber]>;

    totalInvested(
      addy: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    tokenAddress(overrides?: CallOverrides): Promise<[string]>;

    isClaimed(
      orderId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean] & { claimed: boolean }>;

    endPresale(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    mediumBuy(
      ref: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    lockupOf(
      orderId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { timestamp: BigNumber }>;

    tokenFallback(
      arg0: string,
      _value: BigNumberish,
      arg2: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    tokensRemaining(overrides?: CallOverrides): Promise<[BigNumber]>;

    tokensIfInvest(
      investor: string,
      investment: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        instant: BigNumber;
        short: BigNumber;
        medium: BigNumber;
        long: BigNumber;
      }
    >;

    setInitialInvestedAmount(
      investors: string[],
      etherInvested: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    shortBuy(
      ref: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    buyerOf(
      orderId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string] & { orderadmin: string }>;

    redeem(
      orderId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    amountOf(
      orderId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { amount: BigNumber }>;

    setVips(
      investors: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    isVIP(addy: string, overrides?: CallOverrides): Promise<[boolean]>;

    hardCap(overrides?: CallOverrides): Promise<[BigNumber]>;
  };

  sold(overrides?: CallOverrides): Promise<BigNumber>;

  active(overrides?: CallOverrides): Promise<boolean>;

  sizeMultipliers(
    addy: string,
    toBeInvested: BigNumberish,
    overrides?: CallOverrides
  ): Promise<[BigNumber, BigNumber] & { m: BigNumber; d: BigNumber }>;

  etherCollected(overrides?: CallOverrides): Promise<BigNumber>;

  instantBuy(
    ref: string,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  totalRefferred(addy: string, overrides?: CallOverrides): Promise<BigNumber>;

  longBuy(
    ref: string,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  latestOrderId(overrides?: CallOverrides): Promise<BigNumber>;

  totalInvested(addy: string, overrides?: CallOverrides): Promise<BigNumber>;

  tokenAddress(overrides?: CallOverrides): Promise<string>;

  isClaimed(orderId: BigNumberish, overrides?: CallOverrides): Promise<boolean>;

  endPresale(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  mediumBuy(
    ref: string,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  lockupOf(
    orderId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  tokenFallback(
    arg0: string,
    _value: BigNumberish,
    arg2: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  tokensRemaining(overrides?: CallOverrides): Promise<BigNumber>;

  tokensIfInvest(
    investor: string,
    investment: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber] & {
      instant: BigNumber;
      short: BigNumber;
      medium: BigNumber;
      long: BigNumber;
    }
  >;

  setInitialInvestedAmount(
    investors: string[],
    etherInvested: BigNumberish[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  shortBuy(
    ref: string,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  buyerOf(orderId: BigNumberish, overrides?: CallOverrides): Promise<string>;

  redeem(
    orderId: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  amountOf(
    orderId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  setVips(
    investors: string[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  isVIP(addy: string, overrides?: CallOverrides): Promise<boolean>;

  hardCap(overrides?: CallOverrides): Promise<BigNumber>;

  callStatic: {
    sold(overrides?: CallOverrides): Promise<BigNumber>;

    active(overrides?: CallOverrides): Promise<boolean>;

    sizeMultipliers(
      addy: string,
      toBeInvested: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber] & { m: BigNumber; d: BigNumber }>;

    etherCollected(overrides?: CallOverrides): Promise<BigNumber>;

    instantBuy(ref: string, overrides?: CallOverrides): Promise<void>;

    totalRefferred(addy: string, overrides?: CallOverrides): Promise<BigNumber>;

    longBuy(ref: string, overrides?: CallOverrides): Promise<void>;

    latestOrderId(overrides?: CallOverrides): Promise<BigNumber>;

    totalInvested(addy: string, overrides?: CallOverrides): Promise<BigNumber>;

    tokenAddress(overrides?: CallOverrides): Promise<string>;

    isClaimed(
      orderId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    endPresale(overrides?: CallOverrides): Promise<void>;

    mediumBuy(ref: string, overrides?: CallOverrides): Promise<void>;

    lockupOf(
      orderId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    tokenFallback(
      arg0: string,
      _value: BigNumberish,
      arg2: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    tokensRemaining(overrides?: CallOverrides): Promise<BigNumber>;

    tokensIfInvest(
      investor: string,
      investment: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        instant: BigNumber;
        short: BigNumber;
        medium: BigNumber;
        long: BigNumber;
      }
    >;

    setInitialInvestedAmount(
      investors: string[],
      etherInvested: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    shortBuy(ref: string, overrides?: CallOverrides): Promise<void>;

    buyerOf(orderId: BigNumberish, overrides?: CallOverrides): Promise<string>;

    redeem(orderId: BigNumberish, overrides?: CallOverrides): Promise<void>;

    amountOf(
      orderId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    setVips(investors: string[], overrides?: CallOverrides): Promise<void>;

    isVIP(addy: string, overrides?: CallOverrides): Promise<boolean>;

    hardCap(overrides?: CallOverrides): Promise<BigNumber>;
  };

  filters: {
    "Activated(uint256)"(time?: null): ActivatedEventFilter;
    Activated(time?: null): ActivatedEventFilter;

    "Finished(uint256)"(time?: null): FinishedEventFilter;
    Finished(time?: null): FinishedEventFilter;

    "Purchase(address,uint256,uint256,uint256,uint256,uint256,string)"(
      purchaser?: null,
      id?: null,
      amount?: null,
      etherPaid?: null,
      purchasedAt?: null,
      redeemAt?: null,
      hodltype?: null
    ): PurchaseEventFilter;
    Purchase(
      purchaser?: null,
      id?: null,
      amount?: null,
      etherPaid?: null,
      purchasedAt?: null,
      redeemAt?: null,
      hodltype?: null
    ): PurchaseEventFilter;

    "Claim(address,uint256,uint256)"(
      purchaser?: null,
      id?: null,
      amount?: null
    ): ClaimEventFilter;
    Claim(purchaser?: null, id?: null, amount?: null): ClaimEventFilter;
  };

  estimateGas: {
    sold(overrides?: CallOverrides): Promise<BigNumber>;

    active(overrides?: CallOverrides): Promise<BigNumber>;

    sizeMultipliers(
      addy: string,
      toBeInvested: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    etherCollected(overrides?: CallOverrides): Promise<BigNumber>;

    instantBuy(
      ref: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    totalRefferred(addy: string, overrides?: CallOverrides): Promise<BigNumber>;

    longBuy(
      ref: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    latestOrderId(overrides?: CallOverrides): Promise<BigNumber>;

    totalInvested(addy: string, overrides?: CallOverrides): Promise<BigNumber>;

    tokenAddress(overrides?: CallOverrides): Promise<BigNumber>;

    isClaimed(
      orderId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    endPresale(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    mediumBuy(
      ref: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    lockupOf(
      orderId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    tokenFallback(
      arg0: string,
      _value: BigNumberish,
      arg2: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    tokensRemaining(overrides?: CallOverrides): Promise<BigNumber>;

    tokensIfInvest(
      investor: string,
      investment: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    setInitialInvestedAmount(
      investors: string[],
      etherInvested: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    shortBuy(
      ref: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    buyerOf(
      orderId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    redeem(
      orderId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    amountOf(
      orderId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    setVips(
      investors: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    isVIP(addy: string, overrides?: CallOverrides): Promise<BigNumber>;

    hardCap(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    sold(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    active(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    sizeMultipliers(
      addy: string,
      toBeInvested: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    etherCollected(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    instantBuy(
      ref: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    totalRefferred(
      addy: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    longBuy(
      ref: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    latestOrderId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalInvested(
      addy: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    tokenAddress(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isClaimed(
      orderId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    endPresale(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    mediumBuy(
      ref: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    lockupOf(
      orderId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    tokenFallback(
      arg0: string,
      _value: BigNumberish,
      arg2: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    tokensRemaining(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    tokensIfInvest(
      investor: string,
      investment: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    setInitialInvestedAmount(
      investors: string[],
      etherInvested: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    shortBuy(
      ref: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    buyerOf(
      orderId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    redeem(
      orderId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    amountOf(
      orderId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    setVips(
      investors: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    isVIP(
      addy: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    hardCap(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
